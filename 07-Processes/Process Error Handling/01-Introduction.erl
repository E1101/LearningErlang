%% Instead of handling an error in the process
%% where the error occurs, we let the process die and correct the error in some
%% other process.
%% Detecting errors and finding out why something failed is built into the Erlang
%% VM at a very low level and is part of the Erlang programming language.

%% In Erlang We build our applications in two parts:
%% a part that solves the problem and a part that corrects errors if they have
%% occurred.

%% The part that corrects errors is often generic, so the same error-correcting
%% code can be used for many different applications. For example, in database
%% transactions if something goes wrong in the middle of a transaction, we simply
%% abort the transaction and let the system restore the database to the state it
%% was in before the error occurred. In an operating system, if a process crashes,
%% we let the operating system close any open files or sockets and restore the
%% system to a stable state.

%% Processes:
%%  There are two types of processes: normal processes and system processes.
%%  spawn creates a normal process. A normal process can become a system
%%  process by evaluating the BIF process_flag(trap_exit, true).
%%  (meaning that it can trap exit signals).
%%  stopping errors from propagating to other processes in the system.

%% Links:
%%  If the two processes A and B are linked and A
%%  terminates for any reason, an error signal will be sent to B and the other
%%  way around.

%% Link sets:
%%  The link set of a process P is the set of processes that are linked to P .

%% Monitors:
%%  Monitors are similar to links but are one-directional. If A monitors B and
%%  if B terminates for any reason, a “down” message will be sent to A but not
%%  the other way around.
%%
%%  • Monitors are unidirectional. If A monitors B and B dies, then A will be sent
%%    an exit message but not the other way around (recall that links were
%%    bidirectional, so if A and B were linked, the death of either process would
%%    result in the other process being informed).
%%  • When a monitored process dies, a “down” message and not an exit signal
%%    is sent to the monitoring process. This means that the monitoring process
%%    does not have to become a system process in order to handle errors.
%%
%%  ! Monitors are typically used by servers to monitor the behavior of clients.


%% > Receipt of an error signal:

%% When a system process receives an error signal, the signal is converted
%% into a message of the form {'EXIT', Pid, Why} . Pid is the identity of the process
%% that terminated, and Why is the reason for termination (sometimes called
%% the exit reason). If the process terminates without an error, then Why will
%% be the atom normal ; otherwise, Why describes the error.
%% When a normal process receives an error signal, it will terminate if the
%% exit reason is not normal . When it terminates, it also broadcasts an exit
%% signal to its link set.


exit().
exit(Pid, Why).
%% A process can send a “fake” error signal by evaluating exit(Pid, Why) . In this
%% case, Pid will receive an exit signal with the reason Why . The process that
%% called exit/2 does not die
%% When a system process receives a kill signal, it terminates. Kill signals
%% are generated by calling exit(Pid, kill) . This signal bypasses the normal error
%% signal processing mechanism and is not converted into a message.


-module('01-Introduction').
-export([start/0, request/1, loop/0]).

start() ->
  register(add_one, spawn_link(add_one, loop, [])).

request(Int) ->
  add_one ! {request, self(), Int},
  receive
    {result, Result} -> Result
  after 1000  -> timeout
  end.

loop() ->
  receive
    {request, Pid, Msg} ->
      Pid ! {result, Msg + 1}
  end,
  loop().



-module('01-Introduction').
-export([start/0, request/1, loop/0]).

start() ->
  process_flag(trap_exit, true), %% allowing exit signals to be converted to messages of the format {'EXIT', Pid, Reason}
  Pid = spawn_link(add_two, loop, []),
  register(add_two, Pid),
  {ok, Pid}.

request(Int) ->
  add_two ! {request, self(), Int},
    receive
      {result, Result} -> Result;
      {'EXIT', _Pid, Reason} -> {error, Reason}
      after 1000 -> timeout
    end.

loop() ->
  receive
    {request, Pid, Msg} ->
      Pid ! {result, Msg + 2}
  end,
  loop().

